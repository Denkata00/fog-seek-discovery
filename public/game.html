<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Fog & Seek</title>
<link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=Inter:wght@300;400;600&display=swap" rel="stylesheet" />
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    background: #050a12;
    font-family: 'Inter', sans-serif;
    overflow: hidden;
    width: 100vw;
    height: 100vh;
    color: #cdd9e5;
  }

  canvas { position: absolute; top: 0; left: 0; display: block; }

  /* ===== OVERLAY BASE ===== */
  .overlay {
    position: absolute; inset: 0; z-index: 20;
    display: flex; align-items: center; justify-content: center;
    background: rgba(5,10,18,0.88);
    backdrop-filter: blur(6px);
  }
  .panel {
    background: hsl(218 40% 7%);
    border-radius: 16px;
    padding: 40px 32px;
    max-width: 400px; width: 90%;
    text-align: center;
  }

  /* ===== BUTTONS ===== */
  .btn-glow {
    display: block; width: 100%;
    padding: 13px;
    border: none; border-radius: 8px; cursor: pointer;
    font-family: 'Cinzel', serif;
    font-size: 12px; letter-spacing: 3px; text-transform: uppercase; font-weight: 700;
    background: linear-gradient(135deg, hsl(185 80% 38%), hsl(185 80% 28%));
    color: hsl(185 80% 88%);
    box-shadow: 0 0 18px hsl(185 80% 52% / 0.35), inset 0 1px 0 hsl(185 80% 70% / 0.15);
    transition: box-shadow .2s, transform .1s;
    margin-bottom: 8px;
  }
  .btn-glow:hover { box-shadow: 0 0 28px hsl(185 80% 52% / 0.55); transform: translateY(-1px); }

  .btn-outline {
    display: block; width: 100%;
    padding: 10px;
    border: 1px solid hsl(185 80% 52% / 0.35); border-radius: 8px; cursor: pointer;
    font-family: 'Cinzel', serif;
    font-size: 11px; letter-spacing: 2px; text-transform: uppercase;
    background: transparent; color: hsl(185 80% 62%);
    transition: border-color .2s, color .2s;
  }
  .btn-outline:hover { border-color: hsl(185 80% 52% / 0.7); color: hsl(185 80% 72%); }

  /* ===== START SCREEN ===== */
  #start-screen .panel { border: 1px solid hsl(185 80% 52% / 0.35); box-shadow: 0 0 60px hsl(185 80% 52% / 0.12); }
  .glow-orb {
    width: 64px; height: 64px; border-radius: 50%;
    background: hsl(185 80% 52% / 0.12); border: 1px solid hsl(185 80% 52% / 0.5);
    display: flex; align-items: center; justify-content: center;
    margin: 0 auto 24px;
    animation: pulse 2s ease-in-out infinite;
  }
  .glow-orb-inner {
    width: 22px; height: 22px; border-radius: 50%;
    background: hsl(185 80% 52%);
    box-shadow: 0 0 20px hsl(185 80% 52%);
  }
  @keyframes pulse { 0%,100%{box-shadow:0 0 10px hsl(185 80% 52%/0.3)} 50%{box-shadow:0 0 28px hsl(185 80% 52%/0.6)} }

  .game-title { font-family:'Cinzel',serif; font-size:28px; font-weight:700; color:#e8f4f8; text-shadow:0 0 20px hsl(185 80% 52%/0.4); margin-bottom:4px; }
  .game-subtitle { font-size:12px; color:hsl(185 80% 52%); margin-bottom:20px; letter-spacing:2px; }

  .keys-list {
    background: hsl(218 40% 5%); border: 1px solid hsl(218 30% 20%);
    border-radius: 8px; padding: 12px 16px; margin-bottom: 20px; text-align:left;
  }
  .keys-list .row { display:flex; justify-content:space-between; align-items:center; margin:6px 0; }
  .key-badge { font-family:monospace; font-size:11px; padding:2px 8px; border-radius:4px; background:hsl(218 30% 12%); color:hsl(185 80% 52%); }
  .key-desc { font-size:11px; color:hsl(218 20% 55%); }

  .hint-text { font-size:11px; color:hsl(218 20% 50%); line-height:1.6; margin-bottom:20px; }
  .hint-text strong { color:hsl(42 75% 60%); }
  .hint-text .npc-color { color:#bb99ff; }

  /* ===== HUD ===== */
  #hud { position:absolute; z-index:10; width:100%; pointer-events:none; }

  #hud-top {
    position:absolute; top:16px; left:50%; transform:translateX(-50%);
    display:flex; gap:10px; align-items:center; pointer-events:none;
  }
  .hud-pill {
    display:flex; align-items:center; gap:6px;
    padding:6px 16px; border-radius:999px;
    background:rgba(5,10,18,0.85);
    font-size:13px; font-weight:700;
  }
  .hud-pill .label { font-size:11px; font-weight:400; color:rgba(180,195,210,0.5); }
  #timer-pill { border:1px solid rgba(13,206,186,0.3); color:#0dceba; }
  #found-pill { border:1px solid rgba(245,200,66,0.3); color:#f5c842; }
  #hints-pill { border:1px solid rgba(153,102,255,0.3); color:#bb99ff; }

  #hud-legend {
    position:absolute; top:16px; left:16px;
    display:flex; flex-direction:column; gap:6px; pointer-events:none;
  }
  .legend-row { display:flex; align-items:center; gap:8px; }
  .legend-dot { width:10px; height:10px; border-radius:50%; flex-shrink:0; }
  .legend-label { font-size:11px; color:rgba(180,195,210,0.55); }

  /* ===== INTERACT PROMPT ===== */
  #interact-prompt {
    position:absolute; bottom:120px; left:50%; transform:translateX(-50%);
    padding:8px 20px; border-radius:999px;
    background:rgba(5,10,18,0.9);
    display:none; align-items:center; gap:8px;
    pointer-events:none;
    z-index:10;
  }
  #interact-prompt.show { display:flex; }
  .e-badge { font-family:monospace; font-size:11px; padding:2px 8px; border-radius:4px; }
  #interact-text { font-size:12px; color:rgba(200,210,220,0.85); }

  /* ===== JUST FOUND ===== */
  #just-found {
    position:absolute; top:80px; left:50%; transform:translateX(-50%);
    padding:10px 24px; border-radius:999px;
    background:rgba(68,255,136,0.15); border:1px solid rgba(68,255,136,0.6);
    color:#44ff88; font-size:14px; font-weight:700;
    text-shadow:0 0 10px #44ff88;
    display:none; z-index:15;
    animation: fadein .3s ease;
  }
  #just-found.show { display:block; }
  @keyframes fadein { from{opacity:0;transform:translateX(-50%) translateY(-10px)} to{opacity:1;transform:translateX(-50%) translateY(0)} }

  /* ===== NPC DIALOG ===== */
  #dialog {
    position:absolute; bottom:24px; left:50%; transform:translateX(-50%);
    width:90%; max-width:500px; z-index:20;
    display:none;
  }
  #dialog.show { display:block; }
  .dialog-box {
    border-radius:16px; padding:20px;
    background:rgba(5,10,18,0.97); border:1px solid rgba(153,102,255,0.4);
    box-shadow:0 0 30px rgba(153,102,255,0.12);
  }
  .dialog-header { display:flex; align-items:center; gap:8px; margin-bottom:12px; }
  .dialog-dot { width:8px; height:8px; border-radius:50%; background:#bb99ff; box-shadow:0 0 6px #bb99ff; }
  .dialog-name { font-family:'Cinzel',serif; font-size:12px; color:#bb99ff; font-weight:600; }
  .dialog-close-hint { margin-left:auto; font-size:10px; color:rgba(150,160,180,0.45); }
  .dialog-text { font-size:13px; font-style:italic; line-height:1.6; color:rgba(200,215,225,0.85); margin-bottom:12px; }
  .dialog-btn {
    font-size:11px; padding:5px 14px; border-radius:6px; cursor:pointer;
    background:rgba(153,102,255,0.15); color:#bb99ff;
    border:1px solid rgba(153,102,255,0.3);
    pointer-events:all;
  }

  /* ===== MOBILE D-PAD ===== */
  #dpad {
    position:absolute; bottom:24px; right:24px; z-index:10;
    display:none;
    grid-template-columns:repeat(3, 44px);
    grid-template-rows:repeat(3, 44px);
    gap:4px;
  }
  @media (max-width:768px) { #dpad { display:grid; } }
  .dpad-btn {
    border:1px solid rgba(13,206,186,0.3);
    background:rgba(13,206,186,0.12); border-radius:8px;
    color:#0dceba; font-size:20px; font-weight:700;
    cursor:pointer; display:flex; align-items:center; justify-content:center;
    user-select:none; -webkit-user-select:none;
    touch-action:none;
  }
  .e-mobile {
    position:absolute; bottom:130px; right:24px; z-index:10;
    width:56px; height:56px; border-radius:50%;
    background:rgba(245,200,66,0.18); border:1px solid rgba(245,200,66,0.5);
    color:#f5c842; font-size:18px; font-weight:700;
    display:none; align-items:center; justify-content:center;
    cursor:pointer; font-family:'Cinzel',serif;
    touch-action:none;
  }
  @media (max-width:768px) { .e-mobile { display:flex; } }

  /* ===== END SCREENS ===== */
  #won-screen .panel { border:1px solid rgba(68,255,136,0.4); box-shadow:0 0 60px rgba(68,255,136,0.1); }
  #lost-screen .panel { border:1px solid rgba(255,68,68,0.3); box-shadow:0 0 60px rgba(255,68,68,0.08); }

  .end-icon { font-size:50px; margin-bottom:16px; }
  .end-title { font-family:'Cinzel',serif; font-size:24px; font-weight:700; margin-bottom:8px; }
  .end-subtitle { font-size:13px; color:hsl(218 20% 55%); margin-bottom:20px; }
  .end-subtitle strong { color:#f5c842; }

  .stats-grid { display:grid; grid-template-columns:1fr 1fr; gap:12px; margin-bottom:20px; }
  .stat-box { padding:12px; border-radius:8px; background:hsl(218 40% 5%); border:1px solid hsl(218 30% 18%); }
  .stat-val { font-size:18px; font-weight:700; }
  .stat-label { font-size:11px; color:hsl(218 20% 50%); margin-top:2px; }

  .score-box { padding:16px; border-radius:8px; margin-bottom:20px; background:rgba(68,255,136,0.08); border:1px solid rgba(68,255,136,0.2); }
  .score-val { font-family:'Cinzel',serif; font-size:32px; font-weight:700; color:#44ff88; }
  .score-label { font-size:11px; color:hsl(218 20% 50%); margin-top:4px; }


  /* ===== MINIMAP ===== */
  #minimap {
    position:absolute; bottom:16px; left:16px; z-index:10;
    width:120px; height:90px; border-radius:8px; overflow:hidden;
    border:1px solid rgba(13,206,186,0.25);
    background:rgba(5,10,18,0.8);
  }
  #minimap canvas { width:100%; height:100%; }

</style>
</head>
<body>


<!-- ===== CANVAS ===== -->
<canvas id="gameCanvas"></canvas>

<!-- ===== HUD ===== -->
<div id="hud">
  <div id="hud-top">
    <div class="hud-pill" id="timer-pill">
      <span>‚è±</span>
      <span id="timer-val">5:00</span>
    </div>
    <div class="hud-pill" id="found-pill">
      <span>üë§</span>
      <span id="found-val">0<span class="label">/5</span></span>
    </div>
    <div class="hud-pill" id="hints-pill">
      <span>üí°</span>
      <span id="hints-val">0</span>
    </div>
  </div>

  <div id="hud-legend">
    <div class="legend-row"><div class="legend-dot" style="background:#0dceba;box-shadow:0 0 6px #0dceba"></div><span class="legend-label">You</span></div>
    <div class="legend-row"><div class="legend-dot" style="background:#f5c842;box-shadow:0 0 6px #f5c842"></div><span class="legend-label">Hidden (close!)</span></div>
    <div class="legend-row"><div class="legend-dot" style="background:#bb99ff;box-shadow:0 0 6px #bb99ff"></div><span class="legend-label">NPC (E = talk)</span></div>
  </div>
</div>

<!-- ===== INTERACT PROMPT ===== -->
<div id="interact-prompt">
  <span class="e-badge" id="e-badge">E</span>
  <span id="interact-text">Talk to NPC</span>
</div>

<!-- ===== JUST FOUND ===== -->
<div id="just-found"></div>

<!-- ===== DIALOG ===== -->
<div id="dialog">
  <div class="dialog-box">
    <div class="dialog-header">
      <div class="dialog-dot"></div>
      <span class="dialog-name" id="dialog-name">NPC</span>
      <span class="dialog-close-hint">Esc / E to close</span>
    </div>
    <p class="dialog-text" id="dialog-text"></p>
    <button class="dialog-btn" id="dialog-close-btn">Close</button>
  </div>
</div>

<!-- ===== MOBILE ===== -->
<div id="dpad">
  <div></div>
  <button class="dpad-btn" id="btn-up">‚Üë</button>
  <div></div>
  <button class="dpad-btn" id="btn-left">‚Üê</button>
  <button class="dpad-btn" id="btn-down">‚Üì</button>
  <button class="dpad-btn" id="btn-right">‚Üí</button>
</div>
<button class="e-mobile" id="btn-e">E</button>

<!-- ===== MINIMAP ===== -->
<div id="minimap"><canvas id="minimapCanvas"></canvas></div>


<!-- ===== START SCREEN ===== -->
<div class="overlay" id="start-screen">
  <div class="panel">
    <div class="glow-orb"><div class="glow-orb-inner"></div></div>
    <div class="game-title">FOG &amp; SEEK</div>
    <div class="game-subtitle">2D Top-Down ¬∑ Discovery</div>
    <div class="keys-list">
      <div class="row"><span class="key-badge">WASD / ‚Üë‚Üì‚Üê‚Üí</span><span class="key-desc">Move</span></div>
      <div class="row"><span class="key-badge">E</span><span class="key-desc">Find hidden / Talk to NPC</span></div>
      <div class="row"><span class="key-badge">Esc</span><span class="key-desc">Close dialog</span></div>
    </div>
    <p class="hint-text">
      Find <strong>5 hidden people</strong> before time runs out.<br>
      Talk to <span class="npc-color">NPCs (purple)</span> for hints.<br>
      Yellow figures are only visible up close!
    </p>
    <button class="btn-glow" id="start-btn">Enter the Fog</button>
    <button class="btn-outline" id="back-btn">‚Üê Back</button>
  </div>
</div>

<!-- ===== WON SCREEN ===== -->
<div class="overlay" id="won-screen" style="display:none">
  <div class="panel">
    <div class="end-icon">üéâ</div>
    <div class="end-title" style="color:#44ff88;text-shadow:0 0 20px #44ff88">Victory!</div>
    <div class="end-subtitle">You found all 5 hidden people!</div>
    <div class="stats-grid">
      <div class="stat-box"><div class="stat-val" style="color:#0dceba" id="won-time">--</div><div class="stat-label">Time Left</div></div>
      <div class="stat-box"><div class="stat-val" style="color:#bb99ff" id="won-hints">--</div><div class="stat-label">Hints Used</div></div>
    </div>
    <div class="score-box"><div class="score-val" id="won-score">0</div><div class="score-label">Score</div></div>
    <button class="btn-glow" id="won-restart">Play Again</button>
    <button class="btn-outline" id="won-back">‚Üê Home</button>
  </div>
</div>

<!-- ===== LOST SCREEN ===== -->
<div class="overlay" id="lost-screen" style="display:none">
  <div class="panel">
    <div class="end-icon">üå´Ô∏è</div>
    <div class="end-title" style="color:#ff6666;text-shadow:0 0 20px #ff4444">The Fog Consumed You</div>
    <div class="end-subtitle">Found: <strong id="lost-found">0</strong> of 5</div>
    <button class="btn-glow" id="lost-restart">Try Again</button>
    <button class="btn-outline" id="lost-back">‚Üê Home</button>
  </div>
</div>

<script>
// ============================================================
//  CONSTANTS
// ============================================================
const MAP_W = 2400, MAP_H = 1800;
const VISION_R = 130;
const PLAYER_SPEED = 2.8;
const FIND_R = 70;
const NPC_INTERACT_R = 85;
const GAME_DURATION = 300;

// ============================================================
//  MAP DATA
// ============================================================
const ZONE_NAMES = ['the forest','the village','the ruins','the field'];
const ZONE_FEATURES = [
  ['old oaks','dense bushes','fallen trunk'],
  ['abandoned cabin','old mill','the well'],
  ['stone walls','old arches','dark corner'],
  ['the rocks','tall grass','abandoned cart'],
];

function getZone(x, y) {
  if (x < 1200 && y < 900) return 0;
  if (x >= 1200 && y < 900) return 1;
  if (x < 1200 && y >= 900) return 2;
  return 3;
}

const HIDDEN_SPAWN = [
  {id:0,x:320,y:260,zone:0},{id:1,x:1640,y:340,zone:1},
  {id:2,x:820,y:1380,zone:2},{id:3,x:1920,y:1520,zone:3},{id:4,x:980,y:680,zone:0},
];

const NPCS = [
  {id:0,x:750,y:430,zone:0,name:'Old Hunter'},
  {id:1,x:1450,y:580,zone:1,name:'The Wanderer'},
  {id:2,x:380,y:1240,zone:2,name:'The Warden'},
  {id:3,x:1720,y:1180,zone:3,name:'The Hermit'},
];

// ============================================================
//  BUILD MAP OBJECTS
// ============================================================
const MAP_OBJECTS = [];

// Forest trees (zone 0)
[[120,80,28],[260,180,22],[380,130,30],[90,320,25],[330,370,20],[480,270,26],
 [180,480,24],[630,170,28],[740,320,22],[800,130,32],[160,620,20],[400,590,26],
 [580,520,24],[880,270,30],[1020,190,22],[1040,420,26],[830,530,28],[940,680,20],
 [290,730,24],[580,780,22],[730,670,26],[80,780,20],[440,830,24],[1080,570,22],
 [1080,730,26],[50,190,20],[690,770,22],[940,800,24],[840,400,20],[200,300,26],
 [510,650,22],[680,440,28],[1100,350,24],[360,500,20],[750,580,26],[1000,450,22],
 [130,460,28],[450,190,24],[700,100,20],[900,600,22],[1050,650,28],[200,720,24],
].forEach(([x,y,r]) => MAP_OBJECTS.push({x,y,w:r,h:r,type:'tree'}));

// Village buildings (zone 1)
[[1260,80,80,60],[1380,70,100,70],[1560,130,90,80],[1710,90,80,60],[1860,70,110,70],
 [2010,130,90,80],[1310,280,120,80],[1510,260,100,60],[1720,300,80,70],[1910,260,100,80],
 [2110,280,90,60],[2220,130,100,80],[1410,430,80,60],[1610,410,100,70],[1810,440,90,60],
 [2060,410,80,70],[2310,330,100,80],[1260,480,90,60],[2160,480,80,70],[1460,560,110,65],
 [1660,540,90,70],[1960,560,100,60],[2260,530,80,60],[1360,620,90,55],[1560,700,100,60],
 [1760,680,80,65],[2060,700,90,60],[1300,760,70,55],[1500,780,100,60],[1700,760,80,60],
].forEach(([x,y,w,h]) => MAP_OBJECTS.push({x,y,w,h,type:'building'}));

// Ruins (zone 2)
[[80,940,70,9],[190,990,9,65],[340,970,80,9],[510,940,9,55],[140,1090,90,9],[290,1140,9,75],
 [600,990,65,9],[710,1040,9,65],[440,1090,75,9],[810,970,9,85],[900,990,65,9],[190,1240,85,9],
 [390,1290,9,65],[540,1270,75,9],[700,1240,9,55],[850,1140,65,9],[1000,1090,9,75],[290,1390,85,9],
 [490,1440,9,65],[640,1390,75,9],[800,1370,9,55],[950,1340,65,9],[1100,1190,9,75],[1040,1390,65,9],
 [90,1390,9,65],[190,1490,85,9],[390,1540,9,55],[590,1590,75,9],[790,1540,9,65],[990,1490,65,9],
 [250,1650,80,9],[650,1680,70,9],[950,1650,9,60],[1080,1580,60,9],[120,1720,80,9],[500,1750,70,9],
].forEach(([x,y,w,h]) => MAP_OBJECTS.push({x,y,w,h,type:'ruin'}));

// Rocks (zone 3)
[[1310,950,28,18],[1470,1010,22,14],[1620,960,30,20],[1770,1020,25,16],[1920,960,28,18],
 [2070,1010,22,15],[2220,960,26,17],[2370,1020,28,18],[1360,1120,24,16],[1510,1170,28,18],
 [1660,1120,22,14],[1820,1170,26,17],[1970,1120,28,18],[2120,1170,24,16],[2270,1120,22,15],
 [1410,1320,26,17],[1560,1370,28,18],[1710,1320,24,16],[1870,1370,28,18],[2020,1320,22,14],
 [2170,1370,26,17],[2320,1320,28,18],[1310,1520,24,16],[1460,1570,28,18],[1610,1520,22,14],
 [1760,1570,26,17],[1920,1520,28,18],[2070,1570,24,16],[2220,1520,22,15],[2370,1570,26,17],
 [1360,1720,28,18],[1510,1760,22,14],[1660,1720,26,17],[1820,1760,28,18],[2020,1720,22,14],[2220,1760,26,17],
].forEach(([x,y,w,h]) => MAP_OBJECTS.push({x,y,w,h,type:'rock'}));

// ============================================================
//  HINT GENERATION
// ============================================================
function generateHint(player, target) {
  const dx = target.x - player.x, dy = target.y - player.y;
  const dist = Math.sqrt(dx*dx + dy*dy);
  const angle = Math.atan2(dy, dx) * 180 / Math.PI;
  const dirs = ['east','southeast','south','southwest','west','northwest','north','northeast'];
  const dirIdx = ((Math.round((angle + 180) / 45)) % 8 + 8) % 8;
  const dir = dirs[dirIdx];
  const distStr = dist > 900 ? 'very far' : dist > 500 ? 'far' : dist > 250 ? 'nearby' : 'very close';
  const zone = ZONE_NAMES[target.zone];
  const feats = ZONE_FEATURES[target.zone];
  const feat = feats[Math.floor(Math.random() * feats.length)];
  const templates = [
    `I heard a sound to the ${dir}‚Ä¶ ${distStr}, near ${feat} in ${zone}.`,
    `The fog is thicker to the ${dir}. Look near ${feat}.`,
    `Footsteps to the ${dir}, ${distStr}‚Ä¶ in ${zone}.`,
    `I felt a breath from the ${dir}. Near ${feat}.`,
    `In ${zone} to the ${dir}, ${distStr} ‚Äî near ${feat}.`,
    `The birds went silent to the ${dir}. Something hides near ${feat}.`,
    `The grass is trampled to the ${dir}, ${distStr} from here.`,
    `Shadows move in ${zone}, to the ${dir}. Search near ${feat}.`,
  ];
  return templates[Math.floor(Math.random() * templates.length)];
}

// ============================================================
//  COLLISION
// ============================================================
function hasCollision(nx, ny) {
  const PR = 10;
  for (const obj of MAP_OBJECTS) {
    if (obj.type === 'tree' || obj.type === 'bush') {
      const dx = nx - obj.x, dy = ny - obj.y;
      if (Math.sqrt(dx*dx + dy*dy) < obj.w * 0.7 + PR) return true;
    } else if (obj.type === 'building') {
      if (nx+PR > obj.x && nx-PR < obj.x+obj.w && ny+PR > obj.y && ny-PR < obj.y+obj.h) return true;
    }
  }
  return false;
}

// ============================================================
//  PIXEL-ART TILE DRAWING HELPERS
// ============================================================

// --- TILE SIZE & SEED-BASED RNG ---
const TILE = 32;
function seededRand(seed) {
  let s = seed;
  return function() { s = (s * 1664525 + 1013904223) & 0xffffffff; return (s >>> 0) / 0xffffffff; };
}

// --- ZONE BASE COLORS ---
const ZONE_BASE = [
  // Forest: rich green
  { grass: ['#4a7c3f','#3d6b34','#52874a','#3f6e38','#48793e'], dirt: '#7a5c3a', path: '#8d6b42' },
  // Village: warm sandy
  { grass: ['#6b8f4a','#5f8040','#729a52','#627d40','#688840'], dirt: '#a07850', path: '#b8905c' },
  // Ruins: grey-purple stone
  { grass: ['#4a5c4a','#3f523f','#526052','#465548','#4d5d4d'], dirt: '#6a6060', path: '#787070' },
  // Field: bright open
  { grass: ['#5c9448','#508040','#649c50','#547840','#5c8e46'], dirt: '#9a7a45', path: '#b09050' },
];

// Pre-generate tile noise map
const TILE_COLS = Math.ceil(2400 / TILE) + 2;
const TILE_ROWS = Math.ceil(1800 / TILE) + 2;
const TILE_NOISE = new Uint8Array(TILE_COLS * TILE_ROWS);
const TILE_DETAIL = new Uint8Array(TILE_COLS * TILE_ROWS); // flower/stone decoration
(function() {
  const rng = seededRand(42);
  for (let i = 0; i < TILE_NOISE.length; i++) {
    TILE_NOISE[i] = Math.floor(rng() * 5);
    TILE_DETAIL[i] = Math.floor(rng() * 24); // 0-1 = decoration, rest = plain
  }
})();

function getZoneColors(wx, wy) {
  const z = getZone(wx, wy);
  return ZONE_BASE[z];
}

function drawGrassTile(ctx, sx, sy, wx, wy) {
  const col = Math.floor(wx / TILE);
  const row = Math.floor(wy / TILE);
  const idx = row * TILE_COLS + col;
  const noise = TILE_NOISE[idx % TILE_NOISE.length];
  const detail = TILE_DETAIL[idx % TILE_DETAIL.length];
  const zc = getZoneColors(wx, wy);
  const baseColor = zc.grass[noise];

  ctx.fillStyle = baseColor;
  ctx.fillRect(sx, sy, TILE, TILE);

  // Pixel grass texture - darker edge pixels
  ctx.fillStyle = zc.grass[(noise + 2) % 5];
  if (detail < 8) {
    // scattered grass blades
    const rng = seededRand(col * 1000 + row);
    for (let g = 0; g < 4; g++) {
      const gx = sx + Math.floor(rng() * TILE);
      const gy = sy + Math.floor(rng() * TILE);
      ctx.fillRect(gx, gy, 2, 3);
    }
  }

  // Flowers / small details
  if (detail === 0) {
    // yellow flower
    ctx.fillStyle = '#f0d060';
    ctx.fillRect(sx + 8, sy + 10, 3, 3);
    ctx.fillStyle = '#ffffff';
    ctx.fillRect(sx + 9, sy + 9, 1, 1);
  } else if (detail === 1) {
    // white flower
    ctx.fillStyle = '#e8e8d8';
    ctx.fillRect(sx + 20, sy + 18, 3, 3);
  } else if (detail === 2 && getZone(wx, wy) === 3) {
    // field wildflower - purple
    ctx.fillStyle = '#c080e0';
    ctx.fillRect(sx + 14, sy + 8, 2, 2);
  }
}

// Path/dirt tile
function drawDirtTile(ctx, sx, sy, wx, wy) {
  const zc = getZoneColors(wx, wy);
  ctx.fillStyle = zc.path;
  ctx.fillRect(sx, sy, TILE, TILE);
  // some variation pixels
  const col = Math.floor(wx / TILE), row = Math.floor(wy / TILE);
  const rng = seededRand(col * 777 + row * 13);
  ctx.fillStyle = zc.dirt;
  for (let i = 0; i < 6; i++) {
    ctx.fillRect(sx + Math.floor(rng() * TILE), sy + Math.floor(rng() * TILE), 2, 2);
  }
}

// Pre-compute a simple path layout (dirt strip cutting across each zone)
function isPathTile(wx, wy) {
  const z = getZone(wx, wy);
  // Forest: horizontal path around y=450
  if (z === 0) return (wy > 400 && wy < 500) || (wx > 480 && wx < 600);
  // Village: vertical path at x=1500, horizontal at y=350
  if (z === 1) return (wx > 1480 && wx < 1580) || (wy > 300 && wy < 380);
  // Ruins: diagonal-ish paths (just horizontal strips)
  if (z === 2) return (wy > 1200 && wy < 1280) || (wx > 500 && wx < 600);
  // Field: winding path
  if (z === 3) return (wy > 1100 && wy < 1180) || (wx > 1700 && wx < 1800);
  return false;
}

// ===== PIXEL-ART OBJECT DRAWING =====

function drawPixelTree(ctx, x, y, r, zone) {
  // Trunk
  const tw = Math.max(4, Math.floor(r * 0.22));
  const th = Math.floor(r * 0.55);
  const trunkColors = ['#5c3a1e','#6b4422','#4a2e14','#7a5530'];
  const tc = trunkColors[zone % trunkColors.length];
  ctx.fillStyle = tc;
  ctx.fillRect(x - tw/2, y, tw, th);

  // Tree canopy - multi-layer pixel circles for chunky look
  const foliageColors = [
    ['#2d5e1e','#3a7a28','#4a9638','#1e4010'], // forest
    ['#3a6e2a','#4a8a38','#5aa048','#2a5020'], // village
    ['#384a38','#485a48','#3a4e3a','#2a3a2a'], // ruins
    ['#3a8028','#4a9a38','#5aaa48','#2a6018'], // field
  ];
  const fc = foliageColors[zone];

  // Draw chunky pixel tree top
  const layers = [
    { dy: -r*1.1, rx: r*0.6, ry: r*0.5, c: fc[1] },
    { dy: -r*0.8, rx: r*0.85, ry: r*0.7, c: fc[0] },
    { dy: -r*0.5, rx: r, ry: r*0.8, c: fc[0] },
    { dy: -r*0.5, rx: r*0.7, ry: r*0.6, c: fc[2] }, // highlight
    { dy: -r*0.9, rx: r*0.4, ry: r*0.35, c: fc[2] },
  ];
  layers.forEach(l => {
    ctx.beginPath();
    ctx.ellipse(x + (l.dx||0), y + l.dy, l.rx, l.ry, 0, 0, Math.PI*2);
    ctx.fillStyle = l.c;
    ctx.fill();
  });

  // Dark pixel outline dots for pixelated feel
  ctx.fillStyle = fc[3];
  const outlineDots = [
    [-r*0.7, -r*0.3], [r*0.7, -r*0.3], [0, -r*1.2],
    [-r*0.5, -r*0.9], [r*0.5, -r*0.9],
  ];
  outlineDots.forEach(([dx, dy]) => {
    ctx.fillRect(x+dx-1, y+dy-1, 4, 4);
  });
}

function drawPixelBush(ctx, x, y, r, zone) {
  const colors = [
    ['#2d6e1e','#3a8828','#4aa038','#1a4a10'],
    ['#3a6828','#4a8038','#5a9848','#285020'],
    ['#384838','#485848','#3a4a3a','#28382a'],
    ['#3a8028','#4a9838','#5ab848','#286018'],
  ];
  const c = colors[zone];
  ctx.beginPath(); ctx.ellipse(x, y, r, r*0.65, 0, 0, Math.PI*2);
  ctx.fillStyle = c[0]; ctx.fill();
  ctx.beginPath(); ctx.ellipse(x-r*0.3, y-r*0.1, r*0.65, r*0.5, 0, 0, Math.PI*2);
  ctx.fillStyle = c[1]; ctx.fill();
  ctx.beginPath(); ctx.ellipse(x+r*0.3, y-r*0.1, r*0.65, r*0.5, 0, 0, Math.PI*2);
  ctx.fillStyle = c[1]; ctx.fill();
  // highlight
  ctx.beginPath(); ctx.ellipse(x-r*0.15, y-r*0.3, r*0.35, r*0.25, 0, 0, Math.PI*2);
  ctx.fillStyle = c[2]; ctx.fill();
}

function drawPixelBuilding(ctx, x, y, w, h) {
  // Stone base
  ctx.fillStyle = '#c8b890'; ctx.fillRect(x, y, w, h);
  // Stone blocks grid
  ctx.fillStyle = '#a89870';
  const bw = 16, bh = 10;
  for (let by = 0; by < h; by += bh) {
    const offset = (Math.floor(by/bh) % 2) * 8;
    for (let bx = offset; bx < w; bx += bw) {
      ctx.strokeStyle = '#907850'; ctx.lineWidth = 1;
      ctx.strokeRect(x+bx, y+by, bw, bh);
    }
  }
  // Roof (darker top)
  ctx.fillStyle = '#7a5a38'; ctx.fillRect(x, y, w, 8);
  ctx.fillStyle = '#6a4a28'; ctx.fillRect(x, y, w, 3);
  // Door
  const dw = 10, dh = 14;
  ctx.fillStyle = '#5c3a20'; ctx.fillRect(x+w/2-dw/2, y+h-dh, dw, dh);
  ctx.fillStyle = '#4a2e14'; ctx.fillRect(x+w/2-dw/2+2, y+h-dh+3, 3, 3);
  // Windows
  if (w > 55) {
    ctx.fillStyle = '#a0c8e8'; ctx.fillRect(x+8, y+h*0.35, 12, 10);
    ctx.fillStyle = '#80a8c8'; ctx.fillRect(x+10, y+h*0.35+1, 4, 8); // shade
    ctx.strokeStyle = '#5a6a78'; ctx.lineWidth = 1; ctx.strokeRect(x+8, y+h*0.35, 12, 10);
    if (w > 80) {
      ctx.fillStyle = '#a0c8e8'; ctx.fillRect(x+w-20, y+h*0.35, 12, 10);
      ctx.strokeStyle = '#5a6a78'; ctx.lineWidth = 1; ctx.strokeRect(x+w-20, y+h*0.35, 12, 10);
    }
  }
}

function drawPixelRuin(ctx, x, y, w, h) {
  // Crumbled stone wall
  const isHoriz = w > h;
  ctx.fillStyle = '#888070'; ctx.fillRect(x, y, w, h);
  // Block lines
  ctx.strokeStyle = '#706858'; ctx.lineWidth = 1;
  if (isHoriz) {
    for (let bx = 0; bx < w; bx += 12) ctx.strokeRect(x+bx, y, 12, h);
  } else {
    for (let by = 0; by < h; by += 12) ctx.strokeRect(x, y+by, w, 12);
  }
  // Moss patches
  ctx.fillStyle = '#5a7050';
  if (isHoriz) {
    ctx.fillRect(x+4, y, 8, 3); ctx.fillRect(x+w-14, y, 10, 3);
  } else {
    ctx.fillRect(x, y+4, 3, 8); ctx.fillRect(x, y+h-12, 3, 8);
  }
  // Dark gap / crack
  ctx.fillStyle = '#3a3028';
  if (isHoriz && w > 20) ctx.fillRect(x+w*0.4, y, 3, h);
  else if (h > 20) ctx.fillRect(x, y+h*0.4, w, 3);
}

function drawPixelRock(ctx, x, y, w, h) {
  // Base rock
  ctx.beginPath(); ctx.ellipse(x, y, w/2, h/2, 0, 0, Math.PI*2);
  ctx.fillStyle = '#909898'; ctx.fill();
  // Highlight
  ctx.beginPath(); ctx.ellipse(x-w*0.15, y-h*0.2, w*0.3, h*0.25, 0, 0, Math.PI*2);
  ctx.fillStyle = '#b8c0c0'; ctx.fill();
  // Shadow
  ctx.beginPath(); ctx.ellipse(x+w*0.1, y+h*0.15, w*0.35, h*0.25, 0, 0, Math.PI*2);
  ctx.fillStyle = '#6a7070'; ctx.fill();
  // Pixel outline
  ctx.strokeStyle = '#606868'; ctx.lineWidth = 1.5;
  ctx.beginPath(); ctx.ellipse(x, y, w/2, h/2, 0, 0, Math.PI*2); ctx.stroke();
}

function drawPixelLog(ctx, x, y, w, angle) {
  // Fallen log
  ctx.save();
  ctx.translate(x, y);
  ctx.rotate(angle || 0);
  const lw = w, lh = Math.round(w * 0.28);
  ctx.fillStyle = '#8B5C2A'; ctx.fillRect(-lw/2, -lh/2, lw, lh);
  // Wood grain
  ctx.strokeStyle = '#6B3E18'; ctx.lineWidth = 1.5;
  for (let i = 1; i < 4; i++) {
    ctx.beginPath(); ctx.moveTo(-lw/2 + lw*i/4, -lh/2); ctx.lineTo(-lw/2 + lw*i/4, lh/2); ctx.stroke();
  }
  // End caps
  ctx.beginPath(); ctx.ellipse(-lw/2, 0, 4, lh/2, 0, 0, Math.PI*2); ctx.fillStyle = '#A06030'; ctx.fill();
  ctx.beginPath(); ctx.ellipse(lw/2, 0, 4, lh/2, 0, 0, Math.PI*2); ctx.fillStyle = '#A06030'; ctx.fill();
  // Bark highlight
  ctx.fillStyle = '#C07840'; ctx.fillRect(-lw/2+2, -lh/2+2, lw-4, 3);
  ctx.restore();
}

function drawPixelMushroom(ctx, x, y, r) {
  // Stem
  ctx.fillStyle = '#e8dcc8'; ctx.fillRect(x-3, y, 6, 8);
  // Cap
  ctx.beginPath(); ctx.ellipse(x, y, r, r*0.65, 0, 0, Math.PI*2);
  ctx.fillStyle = '#c84028'; ctx.fill();
  // Spots
  ctx.fillStyle = '#f0e0d0';
  [[0,-r*0.2,3,3],[-r*0.35,-r*0.1,2,2],[r*0.3,-r*0.15,2,2]].forEach(([dx,dy,sw,sh]) => {
    ctx.fillRect(x+dx-sw/2, y+dy-sh/2, sw, sh);
  });
}

function drawPixelStump(ctx, x, y, r) {
  // Stump base
  ctx.fillStyle = '#7a5030'; ctx.fillRect(x-r, y-r*0.5, r*2, r);
  // Stump top (rings)
  ctx.beginPath(); ctx.ellipse(x, y-r*0.5, r, r*0.5, 0, 0, Math.PI*2);
  ctx.fillStyle = '#9a6840'; ctx.fill();
  ctx.strokeStyle = '#6a4020'; ctx.lineWidth = 1.5; ctx.stroke();
  ctx.beginPath(); ctx.ellipse(x, y-r*0.5, r*0.6, r*0.3, 0, 0, Math.PI*2);
  ctx.strokeStyle = '#7a5030'; ctx.lineWidth = 1; ctx.stroke();
}

// ===== PIXEL-ART CHARACTERS =====

// --- PLAYER SPRITESHEET ---
const playerSprite = new Image();
playerSprite.src = 'images/player-sprite.png';
let playerSpriteReady = false;
let SPRITE_FW = 32, SPRITE_FH = 32; // frame size (updated on load)
playerSprite.onload = function() {
  SPRITE_FW = Math.floor(playerSprite.width / 5);
  SPRITE_FH = Math.floor(playerSprite.height / 3);
  playerSpriteReady = true;
};

let playerDir = 'down'; // 'down' | 'up' | 'left' | 'right'
let playerMoving = false;
let playerAnimTime = 0;

function drawPixelPlayer(ctx, x, y, t) {
  x = Math.round(x); y = Math.round(y);

  // Glow
  const g = ctx.createRadialGradient(x, y+4, 0, x, y+4, 22);
  g.addColorStop(0, 'rgba(0,220,200,0.35)'); g.addColorStop(1, 'rgba(0,220,200,0)');
  ctx.fillStyle = g; ctx.beginPath(); ctx.arc(x, y+4, 22, 0, Math.PI*2); ctx.fill();

  // Shadow
  ctx.fillStyle = 'rgba(0,0,0,0.3)';
  ctx.beginPath(); ctx.ellipse(x, y+14, 7, 3, 0, 0, Math.PI*2); ctx.fill();

  if (!playerSpriteReady) return; // fallback: just glow until loaded

  // Pick row: 0=down, 1=side, 2=up
  let row = 0;
  if (playerDir === 'up') row = 2;
  else if (playerDir === 'left' || playerDir === 'right') row = 1;

  // Pick frame
  const frameIndex = playerMoving ? Math.floor(playerAnimTime * 14) % 5 : 0;

  const srcX = frameIndex * SPRITE_FW;
  const srcY = row * SPRITE_FH;
  const drawSize = 36;
  const dx = Math.round(x - drawSize / 2);
  const dy = Math.round(y - drawSize / 2);

  ctx.save();
  ctx.imageSmoothingEnabled = false;
  if (playerDir === 'right') {
    ctx.scale(-1, 1);
    ctx.drawImage(playerSprite, srcX, srcY, SPRITE_FW, SPRITE_FH,
      -(dx + drawSize), dy, drawSize, drawSize);
  } else {
    ctx.drawImage(playerSprite, srcX, srcY, SPRITE_FW, SPRITE_FH,
      dx, dy, drawSize, drawSize);
  }
  ctx.restore();
}

function drawPixelNPC(ctx, x, y, t, alpha) {
  ctx.save(); ctx.globalAlpha = alpha;
  x = Math.round(x); y = Math.round(y);
  const bob = Math.sin(t * 1.5) * 1.5;
  y += bob;

  // Glow
  const g = ctx.createRadialGradient(x, y+4, 0, x, y+4, 16);
  g.addColorStop(0, 'rgba(153,102,255,0.4)'); g.addColorStop(1, 'rgba(153,102,255,0)');
  ctx.fillStyle = g; ctx.beginPath(); ctx.arc(x, y+4, 16, 0, Math.PI*2); ctx.fill();

  // Shadow
  ctx.globalAlpha = alpha * 0.5;
  ctx.fillStyle = 'rgba(0,0,0,0.3)';
  ctx.beginPath(); ctx.ellipse(x, y+14, 6, 2.5, 0, 0, Math.PI*2); ctx.fill();
  ctx.globalAlpha = alpha;

  // Robe legs
  ctx.fillStyle = '#6040a0'; ctx.fillRect(x-5, y+8, 11, 7);
  ctx.fillStyle = '#4a3080'; ctx.fillRect(x-5, y+8, 2, 7); // shadow

  // Body / robe
  ctx.fillStyle = '#7748c8'; ctx.fillRect(x-5, y, 10, 10);
  ctx.fillStyle = '#5a38a0'; ctx.fillRect(x-5, y, 2, 10); // shadow
  ctx.fillStyle = '#9968e8'; ctx.fillRect(x+1, y, 3, 10); // highlight
  // Robe detail
  ctx.fillStyle = '#4a2888'; ctx.fillRect(x-1, y+2, 2, 8); // center line

  // Head
  ctx.fillStyle = '#d4b080'; ctx.fillRect(x-4, y-8, 8, 8);
  // Hood
  ctx.fillStyle = '#5030a0'; ctx.fillRect(x-5, y-9, 10, 4);
  ctx.fillRect(x-4, y-8, 2, 3);
  ctx.fillRect(x+3, y-8, 2, 3);
  // Eyes
  ctx.fillStyle = '#cc88ff'; ctx.fillRect(x-2, y-4, 2, 2); ctx.fillRect(x+1, y-4, 2, 2);
  ctx.fillStyle = '#ffffff'; ctx.fillRect(x-1, y-4, 1, 1); ctx.fillRect(x+2, y-4, 1, 1);

  ctx.restore();
}

function drawPixelHidden(ctx, x, y, t, alpha) {
  ctx.save(); ctx.globalAlpha = alpha;
  x = Math.round(x); y = Math.round(y);

  // Glow
  const g = ctx.createRadialGradient(x, y+4, 0, x, y+4, 18);
  g.addColorStop(0, 'rgba(245,200,66,0.45)'); g.addColorStop(1, 'rgba(245,200,66,0)');
  ctx.fillStyle = g; ctx.beginPath(); ctx.arc(x, y+4, 18, 0, Math.PI*2); ctx.fill();

  // Crouched figure (hiding)
  ctx.fillStyle = '#b87820'; // pants
  ctx.fillRect(x-4, y+5, 8, 6);
  ctx.fillStyle = '#d89030'; // shirt
  ctx.fillRect(x-4, y-2, 8, 8);
  ctx.fillStyle = '#c07828'; ctx.fillRect(x-4, y-2, 2, 8); // shadow
  // Head (looking down/away)
  ctx.fillStyle = '#e8c080'; ctx.fillRect(x-4, y-9, 7, 7);
  // Hair
  ctx.fillStyle = '#3a2010'; ctx.fillRect(x-4, y-9, 7, 3);
  ctx.fillRect(x+2, y-8, 2, 5); // side

  ctx.restore();
}

// ===== ADDITIONAL OBJECTS =====

function drawWell(ctx, x, y) {
  // Base
  ctx.fillStyle = '#8a7060'; ctx.fillRect(x-16, y-4, 32, 16);
  ctx.strokeStyle = '#6a5040'; ctx.lineWidth = 1.5; ctx.strokeRect(x-16, y-4, 32, 16);
  // Posts
  ctx.fillStyle = '#6b4422'; ctx.fillRect(x-14, y-16, 5, 20); ctx.fillRect(x+9, y-16, 5, 20);
  // Crossbar
  ctx.fillStyle = '#8B5C2A'; ctx.fillRect(x-14, y-18, 28, 5);
  // Rope
  ctx.strokeStyle = '#c8b060'; ctx.lineWidth = 1.5;
  ctx.beginPath(); ctx.moveTo(x, y-13); ctx.lineTo(x, y+2); ctx.stroke();
  // Roof triangles on posts
  ctx.fillStyle = '#a06838';
  ctx.beginPath(); ctx.moveTo(x-16, y-18); ctx.lineTo(x, y-26); ctx.lineTo(x+16, y-18); ctx.fill();
  ctx.fillStyle = '#7a4a20';
  ctx.beginPath(); ctx.moveTo(x-16, y-18); ctx.lineTo(x, y-22); ctx.lineTo(x+16, y-18); ctx.fill();
}

function drawMillWheel(ctx, x, y, t) {
  // Mill building (bigger)
  drawPixelBuilding(ctx, x-30, y-40, 60, 50);
  // Wheel
  ctx.save(); ctx.translate(x-32, y-15); ctx.rotate(t * 0.3);
  ctx.strokeStyle = '#7a5030'; ctx.lineWidth = 3;
  ctx.beginPath(); ctx.arc(0, 0, 16, 0, Math.PI*2); ctx.stroke();
  for (let i = 0; i < 4; i++) {
    const a = (i/4)*Math.PI*2;
    ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(Math.cos(a)*16, Math.sin(a)*16); ctx.stroke();
    ctx.fillStyle = '#9a6040';
    ctx.fillRect(Math.cos(a)*10-4, Math.sin(a)*10-4, 8, 5);
  }
  ctx.restore();
}

function drawStoneArch(ctx, x, y, w, h) {
  ctx.fillStyle = '#707868';
  // Left pillar
  ctx.fillRect(x, y, 10, h);
  // Right pillar
  ctx.fillRect(x+w-10, y, 10, h);
  // Arch top
  ctx.beginPath();
  ctx.arc(x+w/2, y, w/2, Math.PI, 0, false);
  ctx.lineWidth = 10; ctx.strokeStyle = '#707868'; ctx.stroke();
  ctx.lineWidth = 6; ctx.strokeStyle = '#888070'; ctx.stroke();
  // Stone texture
  ctx.strokeStyle = '#606058'; ctx.lineWidth = 1;
  for (let i = 0; i < h; i+=8) {
    ctx.strokeRect(x, y+i, 10, 8);
    ctx.strokeRect(x+w-10, y+i, 10, 8);
  }
}

function drawTallGrass(ctx, x, y, rng) {
  const h = 12 + Math.floor(rng() * 8);
  ctx.strokeStyle = '#4a8030'; ctx.lineWidth = 2;
  for (let i = 0; i < 3; i++) {
    const gx = x + (i-1)*5;
    ctx.beginPath(); ctx.moveTo(gx, y); ctx.quadraticCurveTo(gx + rng()*8-4, y-h*0.6, gx+rng()*6-3, y-h); ctx.stroke();
  }
  ctx.strokeStyle = '#5a9840'; ctx.lineWidth = 1.5;
  ctx.beginPath(); ctx.moveTo(x, y); ctx.quadraticCurveTo(x+4, y-h*0.5, x+2, y-h+2); ctx.stroke();
}

function drawAbandonedCart(ctx, x, y) {
  // Cart body (tilted)
  ctx.save(); ctx.translate(x, y); ctx.rotate(-0.15);
  ctx.fillStyle = '#8B5C2A'; ctx.fillRect(-24, -8, 48, 16);
  ctx.strokeStyle = '#6a3a10'; ctx.lineWidth = 2; ctx.strokeRect(-24, -8, 48, 16);
  // Planks
  ctx.strokeStyle = '#7a4a18'; ctx.lineWidth = 1;
  for (let px = -20; px < 24; px += 10) { ctx.beginPath(); ctx.moveTo(px,-8); ctx.lineTo(px, 8); ctx.stroke(); }
  ctx.restore();
  // Wheels
  [[x-16, y+8],[x+16, y+8]].forEach(([wx,wy]) => {
    ctx.beginPath(); ctx.arc(wx, wy, 8, 0, Math.PI*2);
    ctx.fillStyle = '#6a3a10'; ctx.fill();
    ctx.strokeStyle = '#3a1a00'; ctx.lineWidth = 2; ctx.stroke();
    ctx.beginPath(); ctx.moveTo(wx-6,wy); ctx.lineTo(wx+6,wy);
    ctx.moveTo(wx,wy-6); ctx.lineTo(wx,wy+6);
    ctx.strokeStyle = '#8B5020'; ctx.lineWidth = 1.5; ctx.stroke();
  });
}

// ============================================================
//  TILE-BASED BACKGROUND RENDERER
// ============================================================
function drawTiledBackground(ctx, cx, cy, W, H) {
  // Calculate visible tile range
  const startCol = Math.max(0, Math.floor(cx / TILE));
  const endCol = Math.min(TILE_COLS-1, Math.ceil((cx + W) / TILE));
  const startRow = Math.max(0, Math.floor(cy / TILE));
  const endRow = Math.min(TILE_ROWS-1, Math.ceil((cy + H) / TILE));

  for (let row = startRow; row <= endRow; row++) {
    for (let col = startCol; col <= endCol; col++) {
      const wx = col * TILE, wy = row * TILE;
      const sx = wx - cx, sy = wy - cy;
      if (isPathTile(wx + TILE/2, wy + TILE/2)) {
        drawDirtTile(ctx, sx, sy, wx, wy);
      } else {
        drawGrassTile(ctx, sx, sy, wx, wy);
      }
    }
  }
}

// ============================================================
//  SPECIAL LANDMARK OBJECTS (per-zone unique scenery)
// ============================================================
function drawLandmarks(ctx, cx, cy, W, H, t) {
  // Forest: logs, stumps, mushrooms, tall grass patches
  const forestLandmarks = [
    { type:'log', x:200, y:300, w:55, a:0.4 },
    { type:'log', x:400, y:180, w:48, a:-0.3 },
    { type:'log', x:650, y:520, w:60, a:0.6 },
    { type:'stump', x:180, y:500, r:14 },
    { type:'stump', x:860, y:240, r:12 },
    { type:'mushroom', x:260, y:360, r:8 },
    { type:'mushroom', x:520, y:490, r:7 },
    { type:'mushroom', x:380, y:610, r:9 },
    { type:'grass', x:120, y:560, s:42 },
    { type:'grass', x:340, y:430, s:67 },
    { type:'grass', x:780, y:480, s:88 },
    { type:'grass', x:950, y:620, s:23 },
    { type:'grass', x:70, y:720, s:55 },
  ];
  // Village: well, mill, crates
  const villageLandmarks = [
    { type:'well', x:1600, y:500 },
    { type:'mill', x:1900, y:200 },
    { type:'grass', x:1350, y:700, s:11 },
    { type:'grass', x:1750, y:650, s:77 },
    { type:'grass', x:2100, y:580, s:33 },
  ];
  // Ruins: arches, stone clusters
  const ruinsLandmarks = [
    { type:'arch', x:200, y:1050, w:50, h:60 },
    { type:'arch', x:550, y:1300, w:50, h:60 },
    { type:'arch', x:880, y:1500, w:50, h:60 },
    { type:'mushroom', x:320, y:1150, r:7 },
    { type:'mushroom', x:700, y:1420, r:8 },
    { type:'grass', x:150, y:1400, s:92 },
    { type:'grass', x:480, y:1620, s:14 },
    { type:'grass', x:820, y:1700, s:61 },
  ];
  // Field: tall grass, cart, rocks cluster
  const fieldLandmarks = [
    { type:'cart', x:1780, y:1300 },
    { type:'grass', x:1350, y:1100, s:38 },
    { type:'grass', x:1550, y:1350, s:74 },
    { type:'grass', x:1800, y:1500, s:19 },
    { type:'grass', x:2050, y:1200, s:86 },
    { type:'grass', x:2250, y:1400, s:47 },
    { type:'grass', x:1450, y:1650, s:62 },
    { type:'grass', x:2300, y:1650, s:28 },
  ];

  const all = [...forestLandmarks, ...villageLandmarks, ...ruinsLandmarks, ...fieldLandmarks];

  all.forEach(lm => {
    const sx = lm.x - cx, sy = lm.y - cy;
    if (sx < -100 || sx > W+100 || sy < -100 || sy > H+100) return;
    if (lm.type === 'log') drawPixelLog(ctx, sx, sy, lm.w, lm.a);
    else if (lm.type === 'stump') drawPixelStump(ctx, sx, sy, lm.r);
    else if (lm.type === 'mushroom') drawPixelMushroom(ctx, sx, sy, lm.r);
    else if (lm.type === 'well') drawWell(ctx, sx, sy);
    else if (lm.type === 'mill') drawMillWheel(ctx, sx, sy, t);
    else if (lm.type === 'arch') drawStoneArch(ctx, sx, sy, lm.w, lm.h);
    else if (lm.type === 'cart') drawAbandonedCart(ctx, sx, sy);
    else if (lm.type === 'grass') drawTallGrass(ctx, sx, sy, seededRand(lm.s));
  });
}

// ============================================================
//  GAME STATE
// ============================================================
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const fogCanvas = document.createElement('canvas');
const fctx = fogCanvas.getContext('2d');
const minimapCanvas = document.getElementById('minimapCanvas');
const mctx = minimapCanvas.getContext('2d');

let phase = 'start'; // 'start' | 'playing' | 'won' | 'lost'
let player = {x: 1200, y: 900};
let camera = {x: 0, y: 0};
let hiddenPeople = [];
let keys = new Set();
let timeLeft = GAME_DURATION;
let hintsUsed = 0;
let foundCount = 0;
let nearNPC = null;
let nearHidden = null;
let interactCooldown = 0;
let dialogOpen = false;
let t = 0;
let lastTs = 0;
let rafId = 0;

// ============================================================
//  RESIZE
// ============================================================
function resize() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
  fogCanvas.width = canvas.width;
  fogCanvas.height = canvas.height;
  minimapCanvas.width = 120;
  minimapCanvas.height = 90;
}
resize();
window.addEventListener('resize', resize);

// ============================================================
//  GAME INIT
// ============================================================
function startGame() {
  phase = 'playing';
  player = {x: 1200, y: 900};
  hiddenPeople = HIDDEN_SPAWN.map(p => ({...p, found: false}));
  timeLeft = GAME_DURATION;
  hintsUsed = 0;
  foundCount = 0;
  t = 0;
  lastTs = 0;
  interactCooldown = 0;
  dialogOpen = false;
  nearNPC = null;
  nearHidden = null;

  // Hide all overlays, show HUD
  document.getElementById('start-screen').style.display = 'none';
  document.getElementById('won-screen').style.display = 'none';
  document.getElementById('lost-screen').style.display = 'none';
  document.getElementById('hud').style.display = 'block';
  document.getElementById('minimap').style.display = 'block';
  closeDialog();
  cancelAnimationFrame(rafId);
  rafId = requestAnimationFrame(loop);
}

function showStart() {
  phase = 'start';
  cancelAnimationFrame(rafId);
  document.getElementById('start-screen').style.display = 'flex';
  document.getElementById('won-screen').style.display = 'none';
  document.getElementById('lost-screen').style.display = 'none';
  document.getElementById('hud').style.display = 'none';
  document.getElementById('minimap').style.display = 'none';
  closeDialog();
}

// Initially hide HUD and minimap
document.getElementById('hud').style.display = 'none';
document.getElementById('minimap').style.display = 'none';

// ============================================================
//  INTERACT
// ============================================================
function interact() {
  if (phase !== 'playing') return;
  if (dialogOpen) { closeDialog(); return; }
  if (interactCooldown > 0) return;
  interactCooldown = 0.5;

  if (nearHidden) {
    nearHidden.found = true;
    foundCount++;
    updateHUD();
    showJustFound(`Found! (${foundCount}/5)`);
    if (foundCount >= 5) {
      setTimeout(() => endGame('won'), 600);
    }
    return;
  }
  if (nearNPC) {
    const unfound = hiddenPeople.filter(p => !p.found);
    if (!unfound.length) return;
    const closest = unfound.reduce((a,b) => {
      const da = Math.hypot(a.x-player.x, a.y-player.y);
      const db = Math.hypot(b.x-player.x, b.y-player.y);
      return da < db ? a : b;
    });
    const hint = generateHint(player, closest);
    hintsUsed++;
    updateHUD();
    openDialog(nearNPC.name, hint);
    interactCooldown = 1;
  }
}

// ============================================================
//  DIALOG
// ============================================================
function openDialog(name, text) {
  dialogOpen = true;
  document.getElementById('dialog-name').textContent = name;
  document.getElementById('dialog-text').textContent = `"${text}"`;
  document.getElementById('dialog').classList.add('show');
}
function closeDialog() {
  dialogOpen = false;
  document.getElementById('dialog').classList.remove('show');
}

// ============================================================
//  HUD UPDATES
// ============================================================
function fmt(s) { return `${Math.floor(s/60)}:${String(Math.floor(s%60)).padStart(2,'0')}`; }

function updateHUD() {
  const tc = timeLeft < 60 ? '#ff4444' : timeLeft < 120 ? '#ff8c00' : '#0dceba';
  const timerEl = document.getElementById('timer-val');
  timerEl.textContent = fmt(timeLeft);
  timerEl.style.color = tc;
  timerEl.style.textShadow = `0 0 10px ${tc}`;
  document.getElementById('found-val').innerHTML = `${foundCount}<span class="label">/5</span>`;
  document.getElementById('hints-val').textContent = hintsUsed;
}

function showJustFound(msg) {
  const el = document.getElementById('just-found');
  el.textContent = '‚úì ' + msg;
  el.classList.add('show');
  setTimeout(() => el.classList.remove('show'), 2000);
}

function updateInteractPrompt() {
  const el = document.getElementById('interact-prompt');
  const badge = document.getElementById('e-badge');
  const text = document.getElementById('interact-text');
  if ((nearHidden || nearNPC) && !dialogOpen) {
    el.classList.add('show');
    if (nearHidden) {
      badge.style.background = '#f5c84222'; badge.style.color = '#f5c842';
      el.style.borderColor = '#f5c84288';
      text.textContent = 'Found! Press E';
    } else {
      badge.style.background = '#9966ff22'; badge.style.color = '#bb99ff';
      el.style.borderColor = '#9966ff88';
      text.textContent = 'Talk to NPC';
    }
  } else {
    el.classList.remove('show');
  }
}

// ============================================================
//  END GAME
// ============================================================
function endGame(result) {
  phase = result;
  cancelAnimationFrame(rafId);
  document.getElementById('hud').style.display = 'none';
  closeDialog();
  if (result === 'won') {
    document.getElementById('won-time').textContent = fmt(timeLeft);
    document.getElementById('won-hints').textContent = hintsUsed;
    document.getElementById('won-score').textContent = Math.max(0, Math.round(timeLeft * 10 - hintsUsed * 50));
    document.getElementById('won-screen').style.display = 'flex';
  } else {
    document.getElementById('lost-found').textContent = foundCount;
    document.getElementById('lost-screen').style.display = 'flex';
  }
}

// ============================================================
//  MINIMAP
// ============================================================
function drawMinimap() {
  const scaleX = 120 / MAP_W, scaleY = 90 / MAP_H;
  mctx.clearRect(0, 0, 120, 90);
  // Zone fills - brighter colors matching the pixel-art palette
  const zones = [
    {x:0,y:0,w:60,h:45,c:'#3a6a30'},   // Forest - rich green
    {x:60,y:0,w:60,h:45,c:'#6a8040'},  // Village - sandy green
    {x:0,y:45,w:60,h:45,c:'#484e44'},  // Ruins - grey-green
    {x:60,y:45,w:60,h:45,c:'#507838'}, // Field - bright green
  ];
  zones.forEach(z => { mctx.fillStyle = z.c; mctx.fillRect(z.x, z.y, z.w, z.h); });
  // Zone border lines
  mctx.strokeStyle = '#2a2010'; mctx.lineWidth = 1;
  mctx.beginPath(); mctx.moveTo(60,0); mctx.lineTo(60,90); mctx.stroke();
  mctx.beginPath(); mctx.moveTo(0,45); mctx.lineTo(120,45); mctx.stroke();
  // Hidden people
  hiddenPeople.forEach(p => {
    if (p.found) { mctx.fillStyle = '#44ff88'; }
    else { mctx.fillStyle = '#f5c84288'; }
    mctx.beginPath();
    mctx.arc(p.x * scaleX, p.y * scaleY, 2, 0, Math.PI*2);
    mctx.fill();
  });
  // NPCs
  NPCS.forEach(n => {
    mctx.fillStyle = '#bb99ff88';
    mctx.beginPath(); mctx.arc(n.x*scaleX, n.y*scaleY, 1.5, 0, Math.PI*2); mctx.fill();
  });
  // Player
  mctx.fillStyle = '#0dceba';
  mctx.beginPath(); mctx.arc(player.x*scaleX, player.y*scaleY, 3, 0, Math.PI*2); mctx.fill();
  mctx.strokeStyle = '#0dceba44'; mctx.lineWidth = 0.5; mctx.stroke();
}

// ============================================================
//  MAIN LOOP
// ============================================================
function loop(ts) {
  const dt = Math.min((ts - (lastTs || ts)) / 1000, 0.05);
  lastTs = ts;
  t += dt;
  if (interactCooldown > 0) interactCooldown -= dt;

  const W = canvas.width, H = canvas.height;

  if (phase === 'playing') {
    // Timer
    timeLeft -= dt;
    if (timeLeft <= 0) { timeLeft = 0; endGame('lost'); return; }
    updateHUD();

    // Movement
    let dx = 0, dy = 0;
    if (keys.has('arrowleft') || keys.has('a')) dx -= 1;
    if (keys.has('arrowright') || keys.has('d')) dx += 1;
    if (keys.has('arrowup') || keys.has('w')) dy -= 1;
    if (keys.has('arrowdown') || keys.has('s')) dy += 1;
    if (dx !== 0 && dy !== 0) { dx *= 0.707; dy *= 0.707; }

    // Update player direction & animation
    playerMoving = (dx !== 0 || dy !== 0);
    if (playerMoving) {
      playerAnimTime += dt;
      if (Math.abs(dx) > Math.abs(dy)) {
        playerDir = dx > 0 ? 'right' : 'left';
      } else {
        playerDir = dy > 0 ? 'down' : 'up';
      }
    }
    const nx = player.x + dx * PLAYER_SPEED;
    const ny = player.y + dy * PLAYER_SPEED;
    if (nx > 15 && nx < MAP_W-15 && !hasCollision(nx, player.y)) player.x = nx;
    if (ny > 15 && ny < MAP_H-15 && !hasCollision(player.x, ny)) player.y = ny;

    // Camera
    camera.x = Math.max(0, Math.min(MAP_W-W, player.x - W/2));
    camera.y = Math.max(0, Math.min(MAP_H-H, player.y - H/2));

    // Proximity
    nearNPC = NPCS.find(n => Math.hypot(n.x-player.x, n.y-player.y) < NPC_INTERACT_R) || null;
    nearHidden = hiddenPeople.find(p => !p.found && Math.hypot(p.x-player.x, p.y-player.y) < FIND_R) || null;
    updateInteractPrompt();
  }

  const cx = camera.x, cy = camera.y;
  const px = player.x - cx, py = player.y - cy;

  // ---- Tiled Background ----
  // Enable pixel-crisp rendering
  ctx.imageSmoothingEnabled = false;
  drawTiledBackground(ctx, cx, cy, W, H);

  // Zone border fences / natural dividers
  // Forest/Village divider (x=1200) - tree line
  // Ruins/Field divider (x=1200) - rocky line  
  // Top/Bottom divider (y=900) - path / stream suggestion
  ctx.save();
  ctx.globalAlpha = 0.35;
  ctx.strokeStyle = '#5a4a30'; ctx.lineWidth = 3;
  ctx.setLineDash([8,6]);
  ctx.beginPath(); ctx.moveTo(1200-cx, -cy); ctx.lineTo(1200-cx, MAP_H-cy); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(-cx, 900-cy); ctx.lineTo(MAP_W-cx, 900-cy); ctx.stroke();
  ctx.setLineDash([]);
  ctx.restore();

  // Draw landmark decorations (logs, mushrooms, well, cart, etc.)
  drawLandmarks(ctx, cx, cy, W, H, t);

  // Map objects (trees, buildings, ruins, rocks) using new pixel-art drawers
  MAP_OBJECTS.forEach(obj => {
    const sx = obj.x-cx, sy = obj.y-cy;
    if (sx < -100 || sx > W+100 || sy < -100 || sy > H+100) return;
    const z = getZone(obj.x, obj.y);
    if (obj.type === 'tree') drawPixelTree(ctx, sx, sy, obj.w, z);
    else if (obj.type === 'building') drawPixelBuilding(ctx, sx, sy, obj.w, obj.h);
    else if (obj.type === 'rock') drawPixelRock(ctx, sx, sy, obj.w, obj.h);
    else if (obj.type === 'ruin') drawPixelRuin(ctx, sx, sy, obj.w, obj.h);
    else if (obj.type === 'bush') drawPixelBush(ctx, sx, sy, obj.w, z);
  });

  // Hidden people (visible only within FIND_R)
  hiddenPeople.forEach(p => {
    if (p.found) return;
    const d = Math.hypot(p.x-player.x, p.y-player.y);
    if (d > FIND_R + 10) return;
    const alpha = Math.max(0, Math.min(1, (FIND_R - d + 10) / 20));
    const sx = p.x-cx, sy = p.y-cy;
    drawPixelHidden(ctx, sx, sy, t, alpha);
    if (d < FIND_R) {
      ctx.save(); ctx.globalAlpha = alpha * 0.9;
      ctx.fillStyle = '#f5c842'; ctx.font = 'bold 14px sans-serif'; ctx.textAlign = 'center';
      ctx.shadowColor = '#f5c842'; ctx.shadowBlur = 6;
      ctx.fillText('E', sx, sy-22+Math.sin(t*4)*2);
      ctx.restore();
    }
  });

  // NPCs
  NPCS.forEach(npc => {
    const d = Math.hypot(npc.x-player.x, npc.y-player.y);
    if (d > VISION_R + 40) return;
    const alpha = Math.min(1, (VISION_R+20-d)/30);
    const sx = npc.x-cx, sy = npc.y-cy;
    drawPixelNPC(ctx, sx, sy, t, alpha);
    if (d < NPC_INTERACT_R) {
      const bob = Math.sin(t*3)*3;
      ctx.save(); ctx.fillStyle = '#9966ff'; ctx.font = 'bold 13px sans-serif';
      ctx.textAlign = 'center'; ctx.shadowColor = '#9966ff'; ctx.shadowBlur = 8;
      ctx.fillText('!', sx, sy-22+bob); ctx.restore();
    }
  });

  // Player
  drawPixelPlayer(ctx, px, py, t);

  // ---- FOG ----
  fctx.clearRect(0, 0, W, H);
  fctx.fillStyle = 'rgba(5,10,18,0.93)'; fctx.fillRect(0, 0, W, H);
  fctx.globalCompositeOperation = 'destination-out';
  const vg = fctx.createRadialGradient(px, py, 0, px, py, VISION_R);
  vg.addColorStop(0, 'rgba(0,0,0,1)');
  vg.addColorStop(0.65, 'rgba(0,0,0,0.85)');
  vg.addColorStop(0.85, 'rgba(0,0,0,0.4)');
  vg.addColorStop(1, 'rgba(0,0,0,0)');
  fctx.fillStyle = vg; fctx.fillRect(0, 0, W, H);
  fctx.globalCompositeOperation = 'source-over';
  ctx.drawImage(fogCanvas, 0, 0);

  // Player glow on top of fog
  ctx.save();
  const pg = ctx.createRadialGradient(px, py, 0, px, py, 18);
  pg.addColorStop(0, 'rgba(0,220,200,0.45)'); pg.addColorStop(1, 'rgba(0,220,200,0)');
  ctx.fillStyle = pg; ctx.beginPath(); ctx.arc(px, py, 18, 0, Math.PI*2); ctx.fill();
  ctx.restore();

  // Found checkmarks
  hiddenPeople.filter(p => p.found).forEach(p => {
    const d = Math.hypot(p.x-player.x, p.y-player.y);
    if (d > VISION_R) return;
    const sx = p.x-cx, sy = p.y-cy;
    ctx.save(); ctx.fillStyle = '#44ff88'; ctx.font = 'bold 16px sans-serif';
    ctx.textAlign = 'center'; ctx.shadowColor = '#44ff88'; ctx.shadowBlur = 8;
    ctx.fillText('‚úì', sx, sy-22); ctx.restore();
  });

  // Minimap
  if (phase === 'playing') drawMinimap();

  rafId = requestAnimationFrame(loop);
}

// ============================================================
//  INPUT
// ============================================================
window.addEventListener('keydown', e => {
  keys.add(e.key.toLowerCase());
  if (['arrowup','arrowdown','arrowleft','arrowright',' '].includes(e.key.toLowerCase())) e.preventDefault();
  if (e.key.toLowerCase() === 'e') interact();
  if (e.key === 'Escape') closeDialog();
});
window.addEventListener('keyup', e => keys.delete(e.key.toLowerCase()));

// Mobile D-pad
function dpadDown(key) { keys.add(key); }
function dpadUp(key) { keys.delete(key); }

['up','down','left','right'].forEach(dir => {
  const btn = document.getElementById('btn-' + dir);
  const key = 'arrow' + dir;
  btn.addEventListener('pointerdown', e => { e.preventDefault(); dpadDown(key); });
  btn.addEventListener('pointerup', e => { e.preventDefault(); dpadUp(key); });
  btn.addEventListener('pointerleave', e => dpadUp(key));
});

document.getElementById('btn-e').addEventListener('pointerdown', e => { e.preventDefault(); interact(); });

// Buttons
document.getElementById('start-btn').addEventListener('click', startGame);
document.getElementById('back-btn').addEventListener('click', () => {
  window.parent.postMessage('navigate-home', '*');
});
document.getElementById('won-restart').addEventListener('click', startGame);
document.getElementById('won-back').addEventListener('click', () => window.parent.postMessage('navigate-home', '*'));
document.getElementById('lost-restart').addEventListener('click', startGame);
document.getElementById('lost-back').addEventListener('click', () => window.parent.postMessage('navigate-home', '*'));
document.getElementById('dialog-close-btn').addEventListener('click', closeDialog);


// ============================================================
//  RENDER LOOP (start screen static render)
// ============================================================
function renderIdle() {
  if (phase !== 'start') return;
  const W = canvas.width, H = canvas.height;
  // Show the tiled world behind the heavy fog on start screen
  ctx.imageSmoothingEnabled = false;
  drawTiledBackground(ctx, 600, 300, W, H);
  // Heavy fog overlay for start screen
  fctx.fillStyle = 'rgba(5,10,18,0.96)'; fctx.fillRect(0, 0, W, H);
  ctx.drawImage(fogCanvas, 0, 0);
  requestAnimationFrame(renderIdle);
}
renderIdle();
</script>
</body>
</html>
